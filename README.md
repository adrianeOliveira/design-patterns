# design-patterns
Play design patterns


Behavorial patterns

	In software engineering, behavioral design patterns are design patterns that identify common communication patterns between objects and realize these patterns. By doing so, these patterns increase flexibility in carrying out this communication.

	Chain of responsability: 
		A way of passing a request between a chain of objects.

	Command:
		Encapsulate a command request as an object.

	Interpreter:
		A way to include language elements in a program.

	Iterator:
		Sequentially access the elements in a program.

	Mediator:
		Defines simplified communication between classes.

	Memento:
		Capture and restore an object's internal state.

	Null Object:
		Designed to act as a default value of an object.

	Observer:
		A way to notifying change to a number of classes.

	State:
		Alter an object's behavior when it's state changes.

	Strategy:
		Encapsulate an algorithm inside a class.

	Template Method:
		Defer the exact steps of an algorithm to a subclass.

	Visitor:
		Defines a new operation to a class without change.


Structural patterns

	In Software Engineering, Structural Design Patterns are Design Patterns that ease the design by identifying a simple way to realize relationships between entities.

	Adapter:
		Match interfaces of different classes.

	Bridge:
		Separates an object's interface from it's implementation.

	Composite:
		A tree structure of simple and composite objects.

	Decorator:
		Add responsibilities to objects dynamically.

	Fa√ßade:
		A single class that represents an entire subsystem.

	Flyweight:
		A fine-grained instance used for efficient sharing.

	Private Class Data:
		Restricts acessor/mutator access.

	Proxy:
		An object representing another object.


Creational patterns

	In software engineering, creational design patterns are design patterns that deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. The basic form of object creation could result in design problems or added complexity to the design. Creational design patterns solve this problem by somehow controlling this object creation.

	Abstract Factory:
		Creates an instance of several families of classes.

	Builder:
		Separates object construction from its representation.

	Factory Method:
		Creates an instance of several derived classes.

	Object Pool:
		Avoid expensive acquisition and release of resources by recycling objects that are
		no longer is use.

	Prototype:
		A fully initialized instance to be copied or cloned.

	Singleton:
		A class of which only a single instance can exist.
